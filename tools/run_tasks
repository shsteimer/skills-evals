#!/usr/bin/env node

/**
 * Test Runner for Agent Skills Evaluation Framework
 *
 * Usage:
 *   ./tools/run_tasks --task <task-name>
 *   ./tools/run_tasks --tags <tag1,tag2>
 *   ./tools/run_tasks --skills <skill1,skill2>
 *
 * Options:
 *   --task <name>         Run specific test(s) by name (supports wildcards)
 *   --tags <tags>         Run tests matching these tags (comma-separated)
 *   --skills <skills>     Run tests using these skills (comma-separated)
 *   --agents <agents>     Agent(s) to test with (default: all agents)
 *                         Options: claude-code, cursor-cli, codex-cli
 */

import { readFileSync, readdirSync, statSync, mkdirSync, existsSync, writeFileSync } from 'fs';
import { join, dirname, relative } from 'path';
import { fileURLToPath } from 'url';
import { parse as parseYaml } from 'yaml';
import { exec, spawn } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const ROOT_DIR = join(__dirname, '..');
const TASKS_DIR = join(ROOT_DIR, 'tasks');
const EVALUATIONS_DIR = join(ROOT_DIR, 'evaluations');

// Parse command line arguments
function parseArgs() {
  const args = process.argv.slice(2);
  const options = {
    test: null,
    tags: [],
    skills: [],
    agents: ['claude-code', 'cursor-cli', 'codex-cli'],
    setupOnly: false
  };

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    const next = args[i + 1];

    switch (arg) {
      case '--test':
        options.test = next;
        i++;
        break;
      case '--tags':
        options.tags = next ? next.split(',').map(t => t.trim()) : [];
        i++;
        break;
      case '--skills':
        options.skills = next ? next.split(',').map(s => s.trim()) : [];
        i++;
        break;
      case '--agents':
        options.agents = next ? next.split(',').map(a => a.trim()) : ['claude-code', 'cursor-cli', 'codex-cli'];
        i++;
        break;
      case '--setup-only':
      case '--dry-run':
        options.setupOnly = true;
        break;
      case '--help':
      case '-h':
        printUsage();
        process.exit(0);
      default:
        if (arg.startsWith('--')) {
          console.error(`Unknown option: ${arg}`);
          printUsage();
          process.exit(1);
        }
    }
  }

  return options;
}

function printUsage() {
  console.log(`
Test Runner for Agent Skills Evaluation Framework

Usage:
  ./tools/run_tasks --task <task-name>
  ./tools/run_tasks --tags <tag1,tag2>
  ./tools/run_tasks --skills <skill1,skill2>

Options:
  --task <name>         Run specific test(s) by name (path to test directory)
  --tags <tags>         Run tests matching these tags (comma-separated)
  --skills <skills>     Run tests using these skills (comma-separated)
  --agents <agents>     Agent(s) to test with (default: all agents)
                        Options: claude-code, cursor-cli, codex-cli
  --setup-only          Set up test environment but don't run agent (shows commands)
  --dry-run             Alias for --setup-only

Examples:
  ./tools/run_tasks --task tasks/unit/building-blocks/create-simple-block
  ./tools/run_tasks --tags blocks,basic
  ./tools/run_tasks --skills building-blocks
  ./tools/run_tasks --tags blocks --agents claude-code,cursor-cli

At least one of --test, --tags, or --skills is required.
`);
}

// Check if agent CLI is available
async function checkAgentAvailability(agent) {
  const agentInfo = {
    'claude-code': {
      binary: 'claude',
      installUrl: 'https://claude.com/claude-code',
      installInstructions: 'Install Claude Code from https://claude.com/claude-code'
    },
    'cursor-cli': {
      binary: 'cursor-agent',
      installUrl: 'https://cursor.com/cli',
      installInstructions: 'Install Cursor CLI from https://cursor.com/cli'
    },
    'codex-cli': {
      binary: 'codex',
      installUrl: 'https://github.com/openai/codex-cli',
      installInstructions: 'Install Codex CLI - see documentation at https://github.com/openai/codex-cli'
    }
  };

  const info = agentInfo[agent];
  if (!info) {
    return { available: false, error: `Unknown agent: ${agent}` };
  }

  try {
    await execAsync(`which ${info.binary}`);
    return { available: true };
  } catch (error) {
    return {
      available: false,
      binary: info.binary,
      installInstructions: info.installInstructions
    };
  }
}

// Validate arguments
async function validateArgs(options) {
  const errors = [];

  // Must have at least one selector
  if (!options.test && options.tags.length === 0 && options.skills.length === 0) {
    errors.push('Must specify at least one of: --test, --tags, or --skills');
  }

  // Validate agent names
  const validAgents = ['claude-code', 'cursor-cli', 'codex-cli'];
  for (const agent of options.agents) {
    if (!validAgents.includes(agent)) {
      errors.push(`Invalid agent: ${agent}. Valid options: ${validAgents.join(', ')}`);
    }
  }

  if (errors.length > 0) {
    console.error('Validation errors:');
    errors.forEach(err => console.error(`  - ${err}`));
    console.error('\nRun --help for usage information.');
    process.exit(1);
  }

  // Check agent availability
  console.log('Checking agent availability...');
  for (const agent of options.agents) {
    const check = await checkAgentAvailability(agent);
    if (!check.available) {
      console.error(`\n✗ Agent not available: ${agent}`);
      if (check.binary) {
        console.error(`  Binary '${check.binary}' not found in PATH`);
      }
      if (check.installInstructions) {
        console.error(`  Installation: ${check.installInstructions}`);
      }
      if (check.error) {
        console.error(`  Error: ${check.error}`);
      }
      process.exit(1);
    } else {
      console.log(`  ✓ ${agent} available`);
    }
  }
  console.log('');
}

// Find all task.yaml files recursively
function findAllTests(dir = TASKS_DIR) {
  const tests = [];

  function walk(currentDir) {
    const entries = readdirSync(currentDir);

    for (const entry of entries) {
      const fullPath = join(currentDir, entry);
      const stat = statSync(fullPath);

      if (stat.isDirectory()) {
        walk(fullPath);
      } else if (entry === 'task.yaml') {
        tests.push(dirname(fullPath));
      }
    }
  }

  walk(dir);
  return tests;
}

// Load and parse a task.yaml file
function loadTest(testDir) {
  const testYamlPath = join(testDir, 'task.yaml');

  if (!existsSync(testYamlPath)) {
    throw new Error(`task.yaml not found in ${testDir}`);
  }

  const content = readFileSync(testYamlPath, 'utf8');
  const test = parseYaml(content);

  // Add metadata
  test._path = testDir;
  test._relativePath = relative(ROOT_DIR, testDir);

  return test;
}

// Filter tests based on options
function filterTests(tests, options) {
  let filtered = tests;

  // Filter by test name/path
  if (options.test) {
    const testPattern = options.test;
    filtered = filtered.filter(test => {
      // Support exact match or path contains
      return test._path.includes(testPattern) || test._relativePath.includes(testPattern);
    });
  }

  // Filter by tags
  if (options.tags.length > 0) {
    filtered = filtered.filter(test => {
      if (!test.tags || test.tags.length === 0) return false;
      // Test must have at least one of the specified tags
      return options.tags.some(tag => test.tags.includes(tag));
    });
  }

  // Filter by skills
  if (options.skills.length > 0) {
    filtered = filtered.filter(test => {
      if (!test.skills || test.skills.length === 0) return false;
      // Test must have at least one of the specified skills
      return options.skills.some(skill => test.skills.includes(skill));
    });
  }

  return filtered;
}

// Sanitize test name for use as directory/branch name
function sanitizeTestName(name) {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '')
    .substring(0, 50); // Keep it reasonable length
}

// Create a branch for this test run
async function createTestBranch(test, agent) {
  // Generate a short unique ID (last 6 chars of timestamp-based)
  const uniqueId = Date.now().toString(36).slice(-6);

  // Simple, realistic branch name like: quote-block-a1b2c3
  const testBaseName = sanitizeTestName(test.name).substring(0, 30);
  const branchName = `${testBaseName}-${uniqueId}`;

  const initialState = test.initial_state || 'main';

  console.log(`  Creating branch: ${branchName} from ${initialState}`);

  try {
    await execAsync(`git branch ${branchName} ${initialState}`);
    return branchName;
  } catch (error) {
    throw new Error(`Failed to create branch: ${error.message}`);
  }
}

// Create worktree for task execution
async function createWorktree(branchName) {
  // Worktrees must be outside the repository's working tree
  // Use temp directory or parent directory
  const worktreeBase = process.env.TMPDIR || '/tmp';
  const worktreePath = join(worktreeBase, 'skills-eval-worktrees', branchName);

  console.log(`  Creating worktree: ${worktreePath}`);

  // Ensure parent directory exists
  mkdirSync(dirname(worktreePath), { recursive: true });

  try {
    await execAsync(`git worktree add "${worktreePath}" ${branchName}`);
    return worktreePath;
  } catch (error) {
    throw new Error(`Failed to create worktree: ${error.message}`);
  }
}

// Remove test artifacts from the branch (tasks/, tools/, EVALUATION_PLAN.md, etc.)
async function cleanupTestArtifacts(worktreePath) {
  console.log(`  Cleaning up test artifacts from worktree`);

  const artifactsToRemove = [
    'tests',
    'tools',
    'test-results',
    'EVALUATION_PLAN.md',
    '.test-worktrees'
  ];

  // Check which artifacts actually exist in git
  const filesToRemove = [];
  for (const artifact of artifactsToRemove) {
    try {
      const { stdout } = await execAsync(`cd "${worktreePath}" && git ls-files ${artifact}`, {
        shell: '/bin/bash'
      });
      const files = stdout.trim().split('\n').filter(f => f);
      if (files.length > 0) {
        filesToRemove.push(artifact);
      }
    } catch (error) {
      // Artifact doesn't exist in git, skip it
    }
  }

  if (filesToRemove.length > 0) {
    await execAsync(`cd "${worktreePath}" && git rm -rf ${filesToRemove.join(' ')}`, {
      shell: '/bin/bash'
    });
    await execAsync(`cd "${worktreePath}" && git commit -m "test: remove evaluation framework artifacts"`, {
      shell: '/bin/bash'
    });
    console.log(`  Removed: ${filesToRemove.join(', ')}`);
  } else {
    console.log(`  No test artifacts to remove`);
  }
}

// Install dependencies in the worktree
async function installDependencies(worktreePath) {
  console.log(`  Installing dependencies...`);

  try {
    // Check if package.json exists
    const packageJsonPath = join(worktreePath, 'package.json');
    if (!existsSync(packageJsonPath)) {
      console.log(`  No package.json found, skipping npm install`);
      return;
    }

    // Run npm install
    await execAsync('npm install --silent', {
      cwd: worktreePath,
      shell: '/bin/bash'
    });
    console.log(`  ✓ Dependencies installed`);
  } catch (error) {
    console.warn(`  Warning: npm install failed: ${error.message}`);
    // Don't fail the entire test run if npm install fails
  }
}

// Setup agent execution (for --setup-only mode)
async function setupAgentExecution(test, agent, worktreePath, timestamp) {
  const testDirName = sanitizeTestName(test.name);
  const outputDir = join(EVALUATIONS_DIR, timestamp, testDirName, agent);

  // Create output directory
  mkdirSync(outputDir, { recursive: true });

  // Prepare the task prompt
  const taskPrompt = test.task;

  // Build agent command
  let agentCommand;
  let agentBinary;

  switch (agent) {
    case 'claude-code':
      agentBinary = 'claude';
      agentCommand = `claude --permission-mode bypassPermissions --output-format json --print "${taskPrompt.replace(/"/g, '\\"')}"`;
      break;
    case 'cursor-cli':
      agentBinary = 'cursor-agent';
      agentCommand = `cursor-agent --force "${taskPrompt.replace(/"/g, '\\"')}"`;
      break;
    case 'codex-cli':
      agentBinary = 'codex';
      agentCommand = `codex exec --dangerously-bypass-approvals-and-sandbox --json -c 'features.web_search=true' "${taskPrompt.replace(/"/g, '\\"')}"`;
      break;
    default:
      throw new Error(`Unknown agent: ${agent}`);
  }

  // Save test info
  const testInfo = {
    task_name: test.name,
    test_path: test._relativePath,
    agent,
    timestamp,
    task: taskPrompt,
    initial_state: test.initial_state || 'main',
    skills_expected: test.skills,
    tags: test.tags || [],
    worktree_path: worktreePath,
    output_dir: outputDir,
    setup_only: true
  };

  const { writeFileSync } = await import('fs');
  writeFileSync(join(outputDir, 'test-info.json'), JSON.stringify(testInfo, null, 2));

  return {
    outputDir,
    command: agentCommand,
    success: null,
    message: 'Setup complete - manual execution required'
  };
}

// Generate chronological execution transcript from JSONL output
function generateExecutionTranscript(jsonlOutput, agentName, taskName) {
  const lines = jsonlOutput.trim().split('\n').filter(line => line.trim());
  const events = [];

  // Parse each line as JSON
  for (const line of lines) {
    try {
      const event = JSON.parse(line);
      events.push(event);
    } catch (e) {
      // Skip lines that aren't valid JSON
    }
  }

  if (events.length === 0) {
    return 'EXECUTION TRANSCRIPT\n\nNo structured output available.\n';
  }

  // Build transcript header
  let transcript = '';
  transcript += '================================================================================\n';
  transcript += 'EXECUTION TRANSCRIPT\n';
  transcript += '================================================================================\n\n';
  transcript += `Task: ${taskName}\n`;
  transcript += `Agent: ${agentName}\n`;
  transcript += `Events: ${events.length}\n\n`;

  // Detect agent format
  const firstEvent = events[0];
  let agentFormat = 'unknown';

  if (firstEvent.type === 'system' && firstEvent.subtype === 'init') {
    agentFormat = 'claude-code';
  } else if (firstEvent.type === 'thread.started') {
    agentFormat = 'codex-cli';
  } else if (firstEvent.type === 'system' && firstEvent.model) {
    agentFormat = 'cursor-cli';
  }

  transcript += `Format: ${agentFormat}\n`;
  transcript += '================================================================================\n\n';

  // Generate chronological transcript based on format
  if (agentFormat === 'claude-code') {
    transcript += transcribeClaudeCode(events);
  } else if (agentFormat === 'cursor-cli') {
    transcript += transcribeCursor(events);
  } else if (agentFormat === 'codex-cli') {
    transcript += transcribeCodex(events);
  } else {
    transcript += 'Unknown format - see stdout.jsonl for raw output\n';
  }

  transcript += '\n================================================================================\n';
  transcript += 'Full JSONL output available in: stdout.jsonl\n';
  transcript += '================================================================================\n';

  return transcript;
}

// Transcribe Claude Code execution
function transcribeClaudeCode(events) {
  let transcript = '';
  let turnNum = 0;

  for (const event of events) {
    if (event.type === 'system' && event.subtype === 'init') {
      transcript += `[SESSION START]\n`;
      transcript += `Model: ${event.model}\n`;
      transcript += `Session: ${event.session_id}\n`;
      if (event.skills && event.skills.length > 0) {
        transcript += `Skills available: ${event.skills.length}\n`;
      }
      transcript += '\n';
    } else if (event.type === 'assistant') {
      turnNum++;
      transcript += `[TURN ${turnNum}]\n`;

      if (event.message && event.message.content && Array.isArray(event.message.content)) {
        for (const item of event.message.content) {
          if (item.type === 'text') {
            transcript += `\nAgent says:\n${wrapText(item.text, 80)}\n`;
          } else if (item.type === 'tool_use') {
            transcript += `\n> Tool: ${item.name}\n`;
            if (item.input) {
              const inputStr = JSON.stringify(item.input, null, 2);
              transcript += `> Input: ${inputStr.substring(0, 200)}${inputStr.length > 200 ? '...' : ''}\n`;
            }
          }
        }
      }
      transcript += '\n';
    } else if (event.type === 'result') {
      transcript += `[RESULT]\n`;
      transcript += `Status: ${event.is_error ? 'ERROR' : 'SUCCESS'}\n`;
      transcript += `Duration: ${(event.duration_ms / 1000).toFixed(1)}s\n`;
      transcript += `Turns: ${event.num_turns}\n`;
      if (event.total_cost_usd) {
        transcript += `Cost: $${event.total_cost_usd.toFixed(4)}\n`;
      }
      if (event.result && typeof event.result === 'string') {
        transcript += `\nFinal response:\n${wrapText(event.result.substring(0, 500), 80)}${event.result.length > 500 ? '\n...(truncated)' : ''}\n`;
      }
      transcript += '\n';
    }
  }

  return transcript;
}

// Transcribe Cursor execution
function transcribeCursor(events) {
  let transcript = '';

  for (const event of events) {
    if (event.type === 'system') {
      transcript += `[SESSION START]\n`;
      transcript += `Model: ${event.model}\n`;
      transcript += `Session: ${event.session_id}\n\n`;
    } else if (event.type === 'user') {
      transcript += `[USER]\n`;
      if (event.message && event.message.content) {
        for (const item of event.message.content) {
          if (item.type === 'text') {
            transcript += `${wrapText(item.text, 80)}\n`;
          }
        }
      }
      transcript += '\n';
    } else if (event.type === 'tool_call') {
      if (event.subtype === 'started' && event.tool_call) {
        // Extract tool name from the tool_call object
        const toolCall = event.tool_call;
        const toolName = Object.keys(toolCall)[0]?.replace('ToolCall', '') || 'unknown';
        const args = toolCall[Object.keys(toolCall)[0]]?.args || {};

        transcript += `> Tool: ${toolName}\n`;

        // Show key arguments
        const argStr = JSON.stringify(args, null, 2);
        if (argStr.length > 150) {
          transcript += `  Args: ${argStr.substring(0, 150)}...\n`;
        } else {
          transcript += `  Args: ${argStr}\n`;
        }
      } else if (event.subtype === 'completed' && event.result) {
        transcript += `  Result: ${typeof event.result === 'string' ? event.result.substring(0, 100) : JSON.stringify(event.result).substring(0, 100)}...\n`;
      }
    } else if (event.type === 'assistant' && event.message) {
      transcript += `\n[ASSISTANT]\n`;
      if (event.message.content && Array.isArray(event.message.content)) {
        for (const item of event.message.content) {
          if (item.type === 'text' && item.text) {
            transcript += `${wrapText(item.text, 80)}\n`;
          }
        }
      }
      transcript += '\n';
    } else if (event.type === 'result') {
      transcript += `\n[RESULT]\n`;
      if (event.response_text) {
        transcript += `${wrapText(event.response_text.substring(0, 500), 80)}\n`;
        if (event.response_text.length > 500) {
          transcript += `\n...(truncated, see full output in stdout.jsonl)\n`;
        }
      }
      transcript += '\n';
    }
  }

  return transcript;
}

// Transcribe Codex execution
function transcribeCodex(events) {
  let transcript = '';

  for (const event of events) {
    if (event.type === 'thread.started') {
      transcript += `[SESSION START]\n`;
      transcript += `Thread: ${event.thread_id}\n\n`;
    } else if (event.type === 'item.completed' && event.item) {
      const item = event.item;
      if (item.type === 'reasoning') {
        transcript += `[REASONING]\n${item.text}\n\n`;
      } else if (item.type === 'command_execution') {
        transcript += `[COMMAND]\n`;
        transcript += `> ${item.command}\n`;
        if (item.aggregated_output) {
          const output = item.aggregated_output.substring(0, 300);
          transcript += `Output: ${output}${item.aggregated_output.length > 300 ? '...(truncated)' : ''}\n`;
        }
        transcript += `Exit code: ${item.exit_code}\n\n`;
      } else if (item.type === 'message') {
        transcript += `[AGENT]\n${wrapText(item.text || '', 80)}\n\n`;
      }
    }
  }

  return transcript;
}

// Wrap text to specified width
function wrapText(text, width) {
  if (!text) return '';
  const lines = text.split('\n');
  const wrapped = [];

  for (const line of lines) {
    if (line.length <= width) {
      wrapped.push(line);
    } else {
      // Simple wrapping - break at spaces
      let current = '';
      const words = line.split(' ');
      for (const word of words) {
        if ((current + ' ' + word).length <= width) {
          current = current ? current + ' ' + word : word;
        } else {
          if (current) wrapped.push(current);
          current = word;
        }
      }
      if (current) wrapped.push(current);
    }
  }

  return wrapped.join('\n');
}

// Execute the agent with the test task
async function executeAgent(test, agent, worktreePath, timestamp) {
  console.log(`  Executing ${agent} with task...`);

  const testDirName = sanitizeTestName(test.name);
  const outputDir = join(EVALUATIONS_DIR, timestamp, testDirName, agent);

  // Create output directory
  mkdirSync(outputDir, { recursive: true });

  // Prepare the task prompt
  const taskPrompt = test.task;

  // Build agent command based on agent type
  let agentCommand;
  let agentBinary;

  switch (agent) {
    case 'claude-code':
      agentBinary = 'claude';
      agentCommand = `claude --permission-mode bypassPermissions --output-format stream-json --verbose --print "${taskPrompt.replace(/"/g, '\\"')}"`;
      break;
    case 'cursor-cli':
      agentBinary = 'cursor-agent';
      agentCommand = `cursor-agent --force --output-format stream-json "${taskPrompt.replace(/"/g, '\\"')}"`;
      break;
    case 'codex-cli':
      agentBinary = 'codex';
      agentCommand = `codex exec --dangerously-bypass-approvals-and-sandbox --json -c 'features.web_search=true' "${taskPrompt.replace(/"/g, '\\"')}"`;
      break;
    default:
      throw new Error(`Unknown agent: ${agent}`);
  }

  console.log(`  Command: ${agentCommand}`);
  console.log(`  Working directory: ${worktreePath}`);
  console.log(`  Output directory: ${outputDir}`);

  // Save test info
  const testInfo = {
    task_name: test.name,
    test_path: test._relativePath,
    agent,
    timestamp,
    task: taskPrompt,
    initial_state: test.initial_state || 'main',
    skills_expected: test.skills, // Skills the test expects to use
    tags: test.tags || [],
    worktree_path: worktreePath, // Full path where test was executed
    output_dir: outputDir
  };

  writeFileSync(join(outputDir, 'test-info.json'), JSON.stringify(testInfo, null, 2));

  console.log('  Executing agent...');

  const startTime = Date.now();
  let success = false;
  let errorMessage = null;

  try {
    // Execute agent using spawn for real-time output
    const result = await new Promise((resolve, reject) => {
      const child = spawn(agentCommand, [], {
        cwd: worktreePath,
        timeout: 600000, // 10 minute timeout
        shell: true, // Use shell to handle quoting properly
        stdio: ['ignore', 'pipe', 'pipe'] // stdin=ignore, stdout=pipe, stderr=pipe
      });

      let stdout = '';
      let stderr = '';
      let lastOutputLine = '';
      let lastPrintTime = Date.now();

      child.stdout.on('data', (data) => {
        stdout += data.toString();
        const lines = data.toString().split('\n').filter(l => l.trim());
        if (lines.length > 0) {
          lastOutputLine = lines[lines.length - 1].substring(0, 80); // Truncate long lines
        }
      });

      child.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      // Print last output line every 5 seconds
      const progressInterval = setInterval(() => {
        const elapsed = ((Date.now() - startTime) / 1000).toFixed(0);
        if (lastOutputLine) {
          process.stdout.write(`\r  [${elapsed}s] ${lastOutputLine}...`);
        } else {
          process.stdout.write(`\r  Running... ${elapsed}s`);
        }
      }, 5000);

      child.on('close', (code) => {
        clearInterval(progressInterval);
        process.stdout.write('\r\x1b[K'); // Clear the progress line

        if (code === 0) {
          resolve({ stdout, stderr });
        } else {
          const error = new Error(`Agent exited with code ${code}`);
          error.stdout = stdout;
          error.stderr = stderr;
          reject(error);
        }
      });

      child.on('error', (error) => {
        clearInterval(progressInterval);
        process.stdout.write('\r\x1b[K'); // Clear the progress line
        reject(error);
      });
    });

    const endTime = Date.now();
    const duration = endTime - startTime;
    const { stdout, stderr } = result;

    // Save raw output as JSONL (stream-json format)
    writeFileSync(join(outputDir, 'stdout.jsonl'), stdout);
    writeFileSync(join(outputDir, 'stderr.txt'), stderr);

    // Generate human-readable transcript from JSONL
    try {
      const transcript = generateExecutionTranscript(stdout, agent, test.name);
      writeFileSync(join(outputDir, 'execution-transcript.txt'), transcript);
      console.log('  ✓ Generated execution transcript');
    } catch (e) {
      console.log('  Warning: Could not generate execution transcript:', e.message);
    }

    // Capture final code state (git diff from initial state)
    try {
      // First capture status before adding files
      const { stdout: statusOutput } = await execAsync('git status --porcelain', {
        cwd: worktreePath,
        shell: '/bin/bash'
      });
      writeFileSync(join(outputDir, 'git-status.txt'), statusOutput);

      // Add all changes (tracked and untracked) to staging
      // Try git add -A first, fall back to git add . if blocked (AI safety)
      try {
        await execAsync('git add -A', {
          cwd: worktreePath,
          shell: '/bin/bash'
        });
      } catch (addError) {
        // If git add -A is blocked (AI safety), try git add .
        if (addError.message && addError.message.includes('not allowed')) {
          console.log('  Warning: git add -A blocked, trying git add .');
          await execAsync('git add .', {
            cwd: worktreePath,
            shell: '/bin/bash'
          });
        } else {
          throw addError;
        }
      }

      // Create diff of all staged changes (includes new files)
      const { stdout: diffOutput } = await execAsync('git diff --cached HEAD', {
        cwd: worktreePath,
        shell: '/bin/bash'
      });
      writeFileSync(join(outputDir, 'code-diff.patch'), diffOutput);
    } catch (e) {
      console.log('  Warning: Could not capture git diff');
      console.log(`  ${e.message}`);
    }

    // Run linting before cleanup (if package.json has lint script)
    try {
      console.log('  Running linting...');
      const { stdout: lintOutput } = await execAsync('npm run lint', {
        cwd: worktreePath,
        shell: '/bin/bash'
      });
      writeFileSync(join(outputDir, 'lint-output.txt'), lintOutput);
      writeFileSync(join(outputDir, 'lint-result.json'), JSON.stringify({
        passed: true,
        output: lintOutput
      }, null, 2));
      console.log('  ✓ Linting passed');
    } catch (e) {
      // Linting failed
      const lintOutput = e.stdout || e.stderr || e.message;
      writeFileSync(join(outputDir, 'lint-output.txt'), lintOutput);
      writeFileSync(join(outputDir, 'lint-result.json'), JSON.stringify({
        passed: false,
        output: lintOutput,
        error: e.message
      }, null, 2));
      console.log('  ⚠ Linting failed (results saved)');
    }

    // Extract skills used and PR link from output
    const transcript = stdout + '\n' + stderr;
    const skillsUsed = extractSkillsFromText(transcript);
    const prLink = extractPRLink(transcript);

    // Update test info with results
    testInfo.skills_used = skillsUsed;
    testInfo.pr_link = prLink || null;
    testInfo.duration_ms = duration;
    testInfo.completed_at = new Date(endTime).toISOString();

    writeFileSync(join(outputDir, 'test-info.json'), JSON.stringify(testInfo, null, 2));

    success = true;
    console.log(`  ✓ Agent completed in ${(duration / 1000).toFixed(1)}s`);
    if (skillsUsed.length > 0) {
      console.log(`  Skills used: ${skillsUsed.join(', ')}`);
    }
    if (prLink) {
      console.log(`  PR: ${prLink}`);
    }

  } catch (error) {
    const endTime = Date.now();
    const duration = endTime - startTime;

    errorMessage = error.message;
    console.error(`  ✗ Agent failed: ${errorMessage}`);

    // Save error details
    writeFileSync(join(outputDir, 'error.txt'), `${errorMessage}\n\n${error.stack || ''}`);
    if (error.stdout) writeFileSync(join(outputDir, 'stdout.txt'), error.stdout);
    if (error.stderr) writeFileSync(join(outputDir, 'stderr.txt'), error.stderr);

    testInfo.error = errorMessage;
    testInfo.duration_ms = duration;
    testInfo.completed_at = new Date(endTime).toISOString();
    writeFileSync(join(outputDir, 'test-info.json'), JSON.stringify(testInfo, null, 2));
  }

  return {
    outputDir,
    success,
    message: success ? 'Agent completed successfully' : errorMessage
  };
}

// Extract skills used from transcript/output
function extractSkillsFromText(text) {
  const skills = new Set();
  const skillPatterns = [
    /Using [Ss]kill:\s*([a-z-]+)/g,
    /Invoking skill:\s*([a-z-]+)/g,
    /\[Skill:\s*([a-z-]+)\]/g
  ];

  for (const pattern of skillPatterns) {
    let match;
    while ((match = pattern.exec(text)) !== null) {
      skills.add(match[1]);
    }
  }

  return Array.from(skills);
}

// Extract PR link from transcript/output
function extractPRLink(text) {
  // Look for GitHub PR URLs
  const prPattern = /https:\/\/github\.com\/[^\/]+\/[^\/]+\/pull\/\d+/;
  const match = text.match(prPattern);
  return match ? match[0] : null;
}

// Cleanup worktree after test
async function cleanupWorktree(worktreePath, branchName) {
  console.log(`  Cleaning up worktree and branch`);

  try {
    await execAsync(`git worktree remove "${worktreePath}" --force`);
    await execAsync(`git branch -D ${branchName}`);
  } catch (error) {
    console.warn(`Warning: Cleanup failed: ${error.message}`);
  }
}

// Run a single test with a single agent
async function runTestWithAgent(test, agent, setupOnly = false, timestamp = null) {
  console.log(`\nRunning task: ${test.name}`);
  console.log(`  Path: ${test._relativePath}`);
  console.log(`  Agent: ${agent}`);

  // Use provided timestamp or create new one
  if (!timestamp) {
    timestamp = new Date().toISOString();
  }

  let branchName, worktreePath;

  try {
    // Create branch
    branchName = await createTestBranch(test, agent);

    // Create worktree
    worktreePath = await createWorktree(branchName);

    // Remove test artifacts from the branch
    await cleanupTestArtifacts(worktreePath);

    // Install dependencies
    await installDependencies(worktreePath);

    if (setupOnly) {
      // Setup-only mode: just show the commands
      const result = await setupAgentExecution(test, agent, worktreePath, timestamp);
      console.log(`\n  ✓ Test environment ready!`);
      console.log(`\n  To run the test manually:`);
      console.log(`    cd "${worktreePath}"`);
      console.log(`    ${result.command}`);
      console.log(`\n  Output will be saved to:`);
      console.log(`    ${result.outputDir}`);
      console.log(`\n  To capture output:`);
      console.log(`    cd "${worktreePath}"`);
      console.log(`    ${result.command} > "${result.outputDir}/stdout.txt" 2> "${result.outputDir}/stderr.txt"`);
      console.log(`\n  To cleanup when done:`);
      console.log(`    git worktree remove --force "${worktreePath}"`);
      console.log(`    git branch -D ${branchName}`);
      console.log(``);
      console.log(`  Note: Use --force since worktree will have modified files`);

      return {
        ...result,
        setupOnly: true,
        branchName,
        worktreePath
      };
    } else {
      // Execute agent
      const result = await executeAgent(test, agent, worktreePath, timestamp);

      console.log(`  Result: ${result.success ? 'SUCCESS' : 'PENDING'}`);
      console.log(`  Output: ${result.outputDir}`);

      return result;
    }

  } catch (error) {
    console.error(`  ERROR: ${error.message}`);
    return {
      success: false,
      error: error.message
    };
  } finally {
    // Cleanup (skip if setup-only mode)
    if (worktreePath && branchName && !setupOnly) {
      await cleanupWorktree(worktreePath, branchName);
    }
  }
}

// Main execution
async function main() {
  console.log('Agent Skills Evaluation Framework - Test Runner\n');

  const options = parseArgs();
  await validateArgs(options);

  console.log('Configuration:');
  if (options.test) console.log(`  Test: ${options.test}`);
  if (options.tags.length > 0) console.log(`  Tags: ${options.tags.join(', ')}`);
  if (options.skills.length > 0) console.log(`  Skills: ${options.skills.join(', ')}`);
  console.log(`  Agents: ${options.agents.join(', ')}`);
  console.log('');

  // Discover all tests
  console.log('Discovering tests...');
  const allTestDirs = findAllTests();
  console.log(`  Found ${allTestDirs.length} test(s)`);

  // Load all tests
  const allTests = allTestDirs.map(loadTest);

  // Filter tests
  const testsToRun = filterTests(allTests, options);
  console.log(`  ${testsToRun.length} test(s) match criteria`);

  if (testsToRun.length === 0) {
    console.log('\nNo tests to run.');
    process.exit(0);
  }

  // Create a single timestamp for this entire run_tasks execution
  const timestamp = new Date().toISOString();
  console.log(`\nRun timestamp: ${timestamp}`);
  console.log(`Results will be saved to: evaluations/${timestamp}/\n`);

  // Run each test with each agent
  const results = [];
  for (const test of testsToRun) {
    for (const agent of options.agents) {
      const result = await runTestWithAgent(test, agent, options.setupOnly, timestamp);
      results.push({
        test: test.name,
        agent,
        ...result
      });
    }
  }

  if (options.setupOnly) {
    console.log('\n=== Setup Complete ===');
    console.log('Test environments are ready. Run the commands above to execute tests manually.');
    console.log('\nNote: Worktrees and branches are NOT cleaned up in setup-only mode.');
    console.log('Use the cleanup commands shown above when you\'re done testing.');
    return;
  }

  // Summary
  console.log('\n=== Summary ===');
  console.log(`Total test runs: ${results.length}`);
  console.log(`Successful: ${results.filter(r => r.success).length}`);
  console.log(`Failed/Pending: ${results.filter(r => !r.success).length}`);

  console.log('\nNext steps:');
  console.log('  1. Review task outputs in evaluations/');
  console.log('  2. Run evaluation: ./tools/evaluate <output-dir>');
  console.log('     Options: --eval-agent <agent>, --skip-flexible');
}

main().catch(error => {
  console.error('Fatal error:', error);
  process.exit(1);
});
